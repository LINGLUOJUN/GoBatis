// Please don't edit this file!
package example_xml

import (
	"errors"
	"reflect"
	"strings"
	"github.com/runner-mei/GoBatis/tests"
	gobatis "github.com/runner-mei/GoBatis"
)



func init() {
	gobatis.Init(func(ctx *gobatis.InitContext) error {
	{ //// Users.FindByID
		if _, exists := ctx.Statements["Users.FindByID"]; !exists {
	sqlStr, err := gobatis.GenerateSelectSQL(ctx.Dialect, ctx.Mapper, 
	reflect.TypeOf(&tests.User{}), 
		[]string{
		"id",
		},
		[]reflect.Type{
		  reflect.TypeOf(new(int64)).Elem(),
		},
		[]gobatis.Filter{
		})
	if err != nil {
		return gobatis.ErrForGenerateStmt(err, "generate Users.FindByID error")
	}
stmt, err := gobatis.NewMapppedStatement(ctx, "Users.FindByID", 
	gobatis.StatementTypeSelect, 
	gobatis.ResultStruct, 
	sqlStr)
if err != nil {
	return err
}
ctx.Statements["Users.FindByID"] = stmt
		}
	}
	{ //// Users.Insert
		if _, exists := ctx.Statements["Users.Insert"]; !exists {
		sqlStr, err := gobatis.GenerateInsertSQL(ctx.Dialect, ctx.Mapper, 
    reflect.TypeOf(&tests.User{}),
		[]string{"u",
		},
    []reflect.Type{
      				reflect.TypeOf((*tests.User)(nil)),
		},false)
		if err != nil {
			return gobatis.ErrForGenerateStmt(err, "generate Users.Insert error")
		}
stmt, err := gobatis.NewMapppedStatement(ctx, "Users.Insert", 
	gobatis.StatementTypeInsert, 
	gobatis.ResultStruct, 
	sqlStr)
if err != nil {
	return err
}
ctx.Statements["Users.Insert"] = stmt
		}
	}
	{ //// Users.Update
		if _, exists := ctx.Statements["Users.Update"]; !exists {
		sqlStr, err :=gobatis.GenerateUpdateSQL(ctx.Dialect, ctx.Mapper, 
					"u.", reflect.TypeOf(&tests.User{}), 
					[]string{
							"id",
				},
				[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
				})
		if err != nil {
			return gobatis.ErrForGenerateStmt(err, "generate Users.Update error")
		}
stmt, err := gobatis.NewMapppedStatement(ctx, "Users.Update", 
	gobatis.StatementTypeUpdate, 
	gobatis.ResultStruct, 
	sqlStr)
if err != nil {
	return err
}
ctx.Statements["Users.Update"] = stmt
		}
	}
	{ //// Users.DeleteByID
		if _, exists := ctx.Statements["Users.DeleteByID"]; !exists {
	sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper, 
	reflect.TypeOf(&tests.User{}), 
		[]string{
		"id",
		},
		[]reflect.Type{
		  reflect.TypeOf(new(int64)).Elem(),
		},
		[]gobatis.Filter{
		})
	if err != nil {
		return gobatis.ErrForGenerateStmt(err, "generate Users.DeleteByID error")
	}
stmt, err := gobatis.NewMapppedStatement(ctx, "Users.DeleteByID", 
	gobatis.StatementTypeDelete, 
	gobatis.ResultStruct, 
	sqlStr)
if err != nil {
	return err
}
ctx.Statements["Users.DeleteByID"] = stmt
		}
	}
	{ //// Users.DeleteAll
		if _, exists := ctx.Statements["Users.DeleteAll"]; !exists {
	sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper, 
	reflect.TypeOf(&tests.User{}), 
		[]string{
		},
		[]reflect.Type{
		},
		[]gobatis.Filter{
		})
	if err != nil {
		return gobatis.ErrForGenerateStmt(err, "generate Users.DeleteAll error")
	}
stmt, err := gobatis.NewMapppedStatement(ctx, "Users.DeleteAll", 
	gobatis.StatementTypeDelete, 
	gobatis.ResultStruct, 
	sqlStr)
if err != nil {
	return err
}
ctx.Statements["Users.DeleteAll"] = stmt
		}
	}
	return nil
	})
}

func NewUsers(ref gobatis.SqlSession) Users {
	if ref == nil {
		panic(errors.New("param 'ref' is nil"))
	}
	if reference, ok := ref.(*gobatis.Reference); ok {
		if reference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		} 
	} else if valueReference, ok := ref.(gobatis.Reference); ok {
		if valueReference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		} 
	}
	return &UsersImpl{session: ref,}
}

type UsersImpl struct {
	session gobatis.SqlSession
}

func (impl *UsersImpl) FindByID(id int64) (*tests.User, error) {
	var instance = &tests.User{}