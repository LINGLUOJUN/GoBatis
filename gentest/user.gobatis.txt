// Please don't edit this file!
package gentest

import (
	"reflect"

	gobatis "github.com/runner-mei/GoBatis"
)

func init() {
	gobatis.Init(func(ctx *gobatis.InitContext) error {
		{ //// AuthUserDao.Insert
			if _, exists := ctx.Statements["AuthUserDao.Insert"]; !exists {
				sqlStr := "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)"
				switch ctx.DbType {
				case gobatis.ToDbType("mssql"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n output inserted.id\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)"
				case gobatis.ToDbType("postgres"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) returning id"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Insert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Insert"] = stmt
			}
		}
		{ //// AuthUserDao.Upsert
			if _, exists := ctx.Statements["AuthUserDao.Upsert"]; !exists {
				sqlStr := ""
				switch ctx.DbType {
				case gobatis.ToDbType("mssql"):
					sqlStr = "MERGE auth_users USING (\r\n     VALUES (?,?,?,?,?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n ) AS foo (username, phone, address, status, birth_day, created_at, updated_at)\r\n ON auth_users.username = foo.username\r\n WHEN MATCHED THEN\r\n    UPDATE SET username=foo.username, phone=foo.phone, address=foo.address, status=foo.status, birth_day=foo.birth_day, updated_at=foo.updated_at\r\n WHEN NOT MATCHED THEN\r\n    INSERT (username, phone, address, status, birth_day, created_at, updated_at)\r\n    VALUES (foo.username, foo.phone, foo.address, foo.status, foo.birth_day,  foo.created_at, foo.updated_at);"
				case gobatis.ToDbType("mysql"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (?,?,?,?,?,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n on duplicate key update\r\n   username=values(username), phone=values(phone), address=values(address),\r\n   status=values(status), birth_day=values(birth_day), updated_at=CURRENT_TIMESTAMP"
				case gobatis.ToDbType("postgres"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (?,?,?,?,?,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n on duplicate key update\r\n   username=values(username), phone=values(phone), address=values(address),\r\n   status=values(status), birth_day=values(birth_day), updated_at=CURRENT_TIMESTAMP"
				}
				if sqlStr == "" {
					s, err := gobatis.GenerateInsertSQL(ctx.DbType, ctx.Mapper,
						reflect.TypeOf(&AuthUser{}), false)
					if err != nil {
						return err
					}
					sqlStr = s
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Upsert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Upsert"] = stmt
			}
		}
		{ //// AuthUserDao.Update
			if _, exists := ctx.Statements["AuthUserDao.Update"]; !exists {
				sqlStr := "UPDATE auth_users\r\n SET username=#{u.username},\r\n     phone=#{u.phone},\r\n     address=#{u.address},\r\n     status=#{u.status},\r\n     birth_day=#{u.birth_day},\r\n     updated_at=CURRENT_TIMESTAMP\r\n WHERE id=#{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Update",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Update"] = stmt
			}
		}
		{ //// AuthUserDao.UpdateName
			if _, exists := ctx.Statements["AuthUserDao.UpdateName"]; !exists {
				sqlStr := "UPDATE auth_users\r\n SET username=#{username},\r\n     updated_at=CURRENT_TIMESTAMP\r\n WHERE id=#{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.UpdateName",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.UpdateName"] = stmt
			}
		}
		{ //// AuthUserDao.DeleteAll
			if _, exists := ctx.Statements["AuthUserDao.DeleteAll"]; !exists {
				sqlStr := "DELETE FROM auth_users"
				switch ctx.DbType {
				case gobatis.ToDbType("postgres"):
					sqlStr = "DELETE FROM auth_users"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.DeleteAll",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.DeleteAll"] = stmt
			}
		}
		{ //// AuthUserDao.Delete
			if _, exists := ctx.Statements["AuthUserDao.Delete"]; !exists {
				sqlStr := "DELETE FROM auth_users WHERE id=?"
				switch ctx.DbType {
				case gobatis.ToDbType("postgres"):
					sqlStr = "DELETE FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Delete",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Delete"] = stmt
			}
		}
		{ //// AuthUserDao.Get
			if _, exists := ctx.Statements["AuthUserDao.Get"]; !exists {
				sqlStr := "select * FROM auth_users WHERE id=?"
				switch ctx.DbType {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select * FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Get",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Get"] = stmt
			}
		}
		{ //// AuthUserDao.GetName
			if _, exists := ctx.Statements["AuthUserDao.GetName"]; !exists {
				sqlStr := "select username FROM auth_users WHERE id=?"
				switch ctx.DbType {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select username FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.GetName",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.GetName"] = stmt
			}
		}
		{ //// AuthUserDao.GetNames
			if _, exists := ctx.Statements["AuthUserDao.GetNames"]; !exists {
				sqlStr := "select username FROM auth_users"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.GetNames",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.GetNames"] = stmt
			}
		}
		{ //// AuthUserDao.GetMap
			if _, exists := ctx.Statements["AuthUserDao.GetMap"]; !exists {
				sqlStr := "select * FROM auth_users WHERE id=?"
				switch ctx.DbType {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select * FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.GetMap",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.GetMap"] = stmt
			}
		}
		{ //// AuthUserDao.Count
			if _, exists := ctx.Statements["AuthUserDao.Count"]; !exists {
				sqlStr := "select count(*) from auth_users"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Count",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Count"] = stmt
			}
		}
		{ //// AuthUserDao.List
			if _, exists := ctx.Statements["AuthUserDao.List"]; !exists {
				sqlStr := "select * from auth_users offset #{offset} limit  #{size}"
				switch ctx.DbType {
				case gobatis.ToDbType("mssql"):
					sqlStr = "select * from auth_users ORDER BY username OFFSET #{offset} ROWS FETCH NEXT #{size}  ROWS ONLY"
				case gobatis.ToDbType("mysql"):
					sqlStr = "select * from auth_users limit #{offset}, #{size}"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.List",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.List"] = stmt
			}
		}
		{ //// AuthUserDao.ListMap
			if _, exists := ctx.Statements["AuthUserDao.ListMap"]; !exists {
				sqlStr := "select * from auth_users offset #{offset} limit  #{size}"
				switch ctx.DbType {
				case gobatis.ToDbType("mssql"):
					sqlStr = "select * from auth_users ORDER BY username OFFSET #{offset} ROWS FETCH NEXT #{size}  ROWS ONLY"
				case gobatis.ToDbType("mysql"):
					sqlStr = "select * from auth_users limit #{offset}, #{size}"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.ListMap",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.ListMap"] = stmt
			}
		}
		{ //// AuthUserDao.GetNameByID
			if _, exists := ctx.Statements["AuthUserDao.GetNameByID"]; !exists {
				sqlStr := "select username from auth_users where id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.GetNameByID",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.GetNameByID"] = stmt
			}
		}
		{ //// AuthUserDao.Roles
			if _, exists := ctx.Statements["AuthUserDao.Roles"]; !exists {
				sqlStr := "select * from auth_roles where exists(\r\n            select * from auth_users_and_roles\r\n            where user_id = #{id} and auth_roles.id = auth_users_and_roles.role_id)"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "AuthUserDao.Roles",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["AuthUserDao.Roles"] = stmt
			}
		}
		return nil
	})
}

func NewAuthUserDao(ref *gobatis.Reference, userProfiles UserProfiles) AuthUserDao {
	return &AuthUserDaoImpl{session: ref,
		userProfiles: userProfiles}
}

type AuthUserDaoImpl struct {
	userProfiles UserProfiles
	session      *gobatis.Reference
}

func (impl *AuthUserDaoImpl) Insert(u *AuthUser) (int64, error) {
	return impl.session.Insert("AuthUserDao.Insert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *AuthUserDaoImpl) Upsert(u *AuthUser) (int64, error) {
	return impl.session.Insert("AuthUserDao.Upsert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *AuthUserDaoImpl) Update(id int64, u *AuthUser) (int64, error) {
	return impl.session.Update("AuthUserDao.Update",
		[]string{
			"id",
			"u",
		},
		[]interface{}{
			id,
			u,
		})
}

func (impl *AuthUserDaoImpl) UpdateName(id int64, username string) (int64, error) {
	return impl.session.Update("AuthUserDao.UpdateName",
		[]string{
			"id",
			"username",
		},
		[]interface{}{
			id,
			username,
		})
}

func (impl *AuthUserDaoImpl) DeleteAll() (int64, error) {
	return impl.session.Delete("AuthUserDao.DeleteAll", nil, nil)
}

func (impl *AuthUserDaoImpl) Delete(id int64) (int64, error) {
	return impl.session.Delete("AuthUserDao.Delete",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
}

func (impl *AuthUserDaoImpl) Get(id int64) (*AuthUser, error) {
	var instance = &AuthUser{}

	err := impl.session.SelectOne("AuthUserDao.Get",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(instance)
	if err != nil {
		return nil, err
	}
	return instance, nil
}

func (impl *AuthUserDaoImpl) GetName(id int64) (string, error) {
	var instance string

	err := impl.session.SelectOne("AuthUserDao.GetName",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return "", err
	}
	return instance, nil
}

func (impl *AuthUserDaoImpl) GetNames() ([]string, error) {
	var instances []string
	results := impl.session.Select("AuthUserDao.GetNames", nil, nil)
	err := results.ScanSlice(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *AuthUserDaoImpl) GetMap(id int64) (map[string]interface{}, error) {
	var instance map[string]interface{}

	err := impl.session.SelectOne("AuthUserDao.GetMap",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return nil, err
	}
	return instance, nil
}

func (impl *AuthUserDaoImpl) Count() (int64, error) {
	var instance int64

	err := impl.session.SelectOne("AuthUserDao.Count", nil, nil).Scan(&instance)
	if err != nil {
		return 0, err
	}
	return instance, nil
}

func (impl *AuthUserDaoImpl) List(offset int, size int) (users []*AuthUser, err error) {
	results := impl.session.Select("AuthUserDao.List",
		[]string{
			"offset",
			"size",
		},
		[]interface{}{
			offset,
			size,
		})
	err = results.ScanSlice(&users)
	if err != nil {
		return nil, err
	}
	return users, nil
}

func (impl *AuthUserDaoImpl) ListMap(offset int, size int) (users map[int64]*AuthUser, err error) {
	results := impl.session.Select("AuthUserDao.ListMap",
		[]string{
			"offset",
			"size",
		},
		[]interface{}{
			offset,
			size,
		})
	err = results.ScanResults(&users)
	if err != nil {
		return nil, err
	}
	return users, nil
}

func (impl *AuthUserDaoImpl) GetNameByID(id int64) (string, error) {
	var instance string

	err := impl.session.SelectOne("AuthUserDao.GetNameByID",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return "", err
	}
	return instance, nil
}

func (impl *AuthUserDaoImpl) Roles(id int64) ([]AuthRole, error) {
	var instances []AuthRole
	results := impl.session.Select("AuthUserDao.Roles",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
	err := results.ScanResults(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *AuthUserDaoImpl) InsertProfile(profile *UserProfile) (int64, error) {
	return impl.userProfiles.Insert(profile)
}

func (impl *AuthUserDaoImpl) DeleteProfile(userID int64) (int64, error) {
	return impl.userProfiles.DeleteAll(userID)
}

func (impl *AuthUserDaoImpl) Profiles(userID int64) ([]*UserProfile, error) {
	return impl.userProfiles.List(userID)
}

func init() {
	gobatis.Init(func(ctx *gobatis.InitContext) error {
		{ //// UserProfiles.Insert
			if _, exists := ctx.Statements["UserProfiles.Insert"]; !exists {
				sqlStr, err := gobatis.GenerateInsertSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), false)
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.Insert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Insert"] = stmt
			}
		}
		{ //// UserProfiles.Update
			if _, exists := ctx.Statements["UserProfiles.Update"]; !exists {
				sqlStr, err := gobatis.GenerateUpdateSQL(ctx.DbType, ctx.Mapper,
					"u.", reflect.TypeOf(&UserProfile{}), []string{
						"id"})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.Update",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Update"] = stmt
			}
		}
		{ //// UserProfiles.DeleteAll
			if _, exists := ctx.Statements["UserProfiles.DeleteAll"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), []string{
						"userID"})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.DeleteAll",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.DeleteAll"] = stmt
			}
		}
		{ //// UserProfiles.Delete
			if _, exists := ctx.Statements["UserProfiles.Delete"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), []string{
						"id"})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.Delete",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Delete"] = stmt
			}
		}
		{ //// UserProfiles.Get
			if _, exists := ctx.Statements["UserProfiles.Get"]; !exists {
				sqlStr, err := gobatis.GenerateSelectSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), []string{
						"id",
					})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.Get",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Get"] = stmt
			}
		}
		{ //// UserProfiles.List
			if _, exists := ctx.Statements["UserProfiles.List"]; !exists {
				sqlStr, err := gobatis.GenerateSelectSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), []string{
						"userID",
					})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.List",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.List"] = stmt
			}
		}
		{ //// UserProfiles.Count
			if _, exists := ctx.Statements["UserProfiles.Count"]; !exists {
				sqlStr, err := gobatis.GenerateCountSQL(ctx.DbType, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), []string{})
				if err != nil {
					return err
				}
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.Count",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Count"] = stmt
			}
		}
		{ //// UserProfiles.GetAndUser
			if _, exists := ctx.Statements["UserProfiles.GetAndUser"]; !exists {
				sqlStr := "SELECT p.id,\r\n                 p.user_id,\r\n                 p.name,\r\n                 p.value,\r\n                 p.created_at,\r\n                 p.updated_at,\r\n                 u.id,\r\n                 u.name,\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.GetAndUser",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.GetAndUser"] = stmt
			}
		}
		{ //// UserProfiles.ListAndUsers
			if _, exists := ctx.Statements["UserProfiles.ListAndUsers"]; !exists {
				sqlStr := "SELECT p.id,\r\n                 p.user_id,\r\n                 p.name,\r\n                 p.value,\r\n                 p.created_at,\r\n                 p.updated_at,\r\n                 u.id,\r\n                 u.name,\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.user_id = #{userID}"
				stmt, err := gobatis.NewMapppedStatement(ctx.Logger, "UserProfiles.ListAndUsers",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.ListAndUsers"] = stmt
			}
		}
		return nil
	})
}

func NewUserProfiles(ref *gobatis.Reference) UserProfiles {
	return &UserProfilesImpl{session: ref}
}

type UserProfilesImpl struct {
	session *gobatis.Reference
}

func (impl *UserProfilesImpl) Insert(u *UserProfile) (int64, error) {
	return impl.session.Insert("UserProfiles.Insert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *UserProfilesImpl) Update(id int64, u *UserProfile) (int64, error) {
	return impl.session.Update("UserProfiles.Update",
		[]string{
			"id",
			"u",
		},
		[]interface{}{
			id,
			u,
		})
}

func (impl *UserProfilesImpl) DeleteAll(userID int64) (int64, error) {
	return impl.session.Delete("UserProfiles.DeleteAll",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		})
}

func (impl *UserProfilesImpl) Delete(id int64) (int64, error) {
	return impl.session.Delete("UserProfiles.Delete",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
}

func (impl *UserProfilesImpl) Get(id int64) (*UserProfile, error) {
	var instance = &UserProfile{}

	err := impl.session.SelectOne("UserProfiles.Get",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(instance)
	if err != nil {
		return nil, err
	}
	return instance, nil
}

func (impl *UserProfilesImpl) List(userID int64) ([]*UserProfile, error) {
	var instances []*UserProfile
	results := impl.session.Select("UserProfiles.List",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		})
	err := results.ScanSlice(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *UserProfilesImpl) Count() (int64, error) {
	var instance int64

	err := impl.session.SelectOne("UserProfiles.Count", nil, nil).Scan(&instance)
	if err != nil {
		return 0, err
	}
	return instance, nil
}

func (impl *UserProfilesImpl) GetAndUser(id int64) (p *UserProfile, u *AuthUser, err error) {
	var instance = gobatis.NewMultiple()
	instance.Set("p", &p)
	instance.Set("u", &u)

	err = impl.session.SelectOne("UserProfiles.GetAndUser",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return nil, nil, err
	}
	return p, u, nil
}

func (impl *UserProfilesImpl) ListAndUsers(userID int) (p []*UserProfile, u []*AuthUser, err error) {
	var instance = gobatis.NewMultipleArray()
	instance.Set("p", &p)
	instance.Set("u", &u)

	err = impl.session.Select("UserProfiles.ListAndUsers",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		}).Scan(&instance)
	if err != nil {
		return nil, nil, err
	}
	return p, u, nil
}
